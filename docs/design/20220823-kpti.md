
# 内核地址隔离

**原理** 先切换到跳板页上的单页表微型内核，再从这个微型内核引导用户态。

本文描述了一种设计，目的是实现单页表内核和双页表内核的一致性。位于不同地址空间的任务被传递给一个公共地址空间（称为中转地址空间）上的独立调度器（称为中转内核），由这个内核进行中转调度。中转内核在主内核上表现为一个屏蔽中断的内核线程（即一个正常的任务）。

## 设计

### 中转内核布局

| 内容
| -
| 共享用户上下文
| `execute`
| `trap`
| 中转内核入口
| 中转内核栈

### 中转内核编译

中转内核在编译时是主内核的一部分。主内核应该在自己的链接脚本上留一个页，然后将中转内核代码段直接链接到页中间的一个位置，保证页开头到中转内核入口之间足够容纳上表描述的内容（估计 1 KiB 够了）。中转内核代码段必须是可重定位的，可以直接手写汇编实现。

### 中转内核初始化

主内核依次拷贝 `execute` `trap` 到中转内核页上，并初始化一个中转内核上下文，内容包括：

- `sp` = 中转内核栈顶（如果中转页在最高虚页上，是 0）
- `a0` = 跳板页基地址/共享用户上下文基地址
- `a1` = `execute` 地址
- `a2` = `trap` 地址
- `sepc` = 中转内核入口
- `sstatus` = S 态屏蔽中断

### 执行用户程序

1. 主内核填写共享用户上下文，内容包括基本任务上下文和用户根页表；
2. 主内核执行中转内核上下文，切换到中转内核线程
3. 中转内核切换上下文 CSR：`satp`、`stvec`、`sscratch`
   - 初次进入时还要将 `a0`、`a1`、`a2` 保存在栈上
   - 完成时到达用户空间
4. 执行共享用户上下文

### 处理用户陷入

1. 用户陷入到中转内核的 `trap`
   > 用户上下文已被保存在共享上下文区域
2. 中转内核切换上下文 CSR：`satp`、`stvec`、`sscratch`
   - 完成时回到内核空间
3. 模拟中断操作设置 `sepc`
4. 直接跳转内核的 `stvec` 回到主内核

## 实现

### 定位上下文切换例程

上下文切换例程是手写内联汇编实现的，可以人工保证它们可重定位（不用 `la` 就行了），以便拷贝到任意位置使用。
可以通过找结尾指令在运行时定位这些函数，并拷贝到其他位置，以 `execute` 为例：

```rust
/// 通过寻找结尾的指令在运行时定位一个函数。
unsafe fn locate_function<const N: usize>(entry: usize, key: [u16; N]) -> &'static [u8] {
    use core::{mem::size_of, slice::from_raw_parts};
    let entry = entry as *const u16;
    for len in 1.. {
        let ptr = entry.add(len);
        if key == from_raw_parts(ptr, key.len()) {
            return from_raw_parts(entry.cast(), size_of::<u16>() * (len + key.len()));
        }
    }
    unreachable!()
}

/// 运行时定位 `locate` 函数。
#[inline]
pub fn locate_execute() -> &'static [u8] {
    // sret + unimp
    unsafe { locate_function(execute as _, [0x0073, 0x1020, 0x0000]) }
}
```

### 中转内核布局

直接用一个 `#[repr(C)]` 结构体定义中转内核布局：

```rust
/// 中转内核布局。
#[repr(C)]
pub struct TransitKernel {
    /// 共享任务上下文。
    pub shared_context: ForeignContext,
    /// `execute` 的拷贝。
    ///
    /// 512 Bytes，4 字节对齐。
    pub execute_copy: [u32; 128],
    /// `trap` 的拷贝。
    ///
    /// 512 Bytes，4 字节对齐。
    pub trap_copy: [u32; 128],
    // 中转内核控制流，直接链接进来。
    // pub main: [u32; 512],
    // 页上其余部分用作栈，运行时设置。
    // pub stack: [u8],
}

/// 位于不同地址空间的任务上下文。
#[repr(C)]
pub struct ForeignContext {
    /// `satp` 寄存器值指定地址空间。
    pub satp: usize,
    /// 正常的任务上下文。
    pub context: Context,
}

/// 中转内核控制流。
#[inline(never)]
#[link_section = ".transit.entry"]
pub extern "C" fn transit_main(
    _ctx: &'static mut ForeignContext,
    _execute_copy: unsafe extern "C" fn(),
    _trap_copy: unsafe extern "C" fn(),
) {
    todo!()
}
```

`execute` 和 `trap` 会在运行时定位并拷贝到结构体。
